# -*- coding: utf-8 -*-
"""part2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oC0Fd6u6m8p3gKrF-Tk-A-WfBNBtAyBr

# Yacht Hydrodynamics Data Set
<br>

**About the Dataset**

1. Prediction of residuary resistance of sailing yachts at the initial design stage is of a great value for evaluating the ship's performance and for estimating the required propulsive power. 

2. Essential inputs include the basic hull dimensions and the boat velocity. 

3. The Delft data set comprises 308 full-scale experiments, which were performed at the Delft Ship Hydromechanics Laboratory for that purpose. 


<br>

**Attribute Information**

*Variations concern hull geometry coefficients and the Froude number:*

1. Longitudinal position of the center of buoyancy, adimensional.
2. Prismatic coefficient, adimensional.
3. Length-displacement ratio, adimensional.
4. Beam-draught ratio, adimensional.
5. Length-beam ratio, adimensional.
6. Froude number, adimensional.

*The measured variable is the residuary resistance per unit weight of displacement:*

7. Residuary resistance per unit weight of displacement, adimensional.

<br>
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd

import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split

from sklearn.linear_model import SGDRegressor
from sklearn.model_selection import GridSearchCV

sns.set_style("darkgrid")
# %matplotlib inline

df = pd.read_csv("https://archive.ics.uci.edu/ml/machine-learning-databases/00243/yacht_hydrodynamics.data",
                 delimiter=" ",
                 names=["lng_pos","pris_coeff","ld_ratio","bd_ratio","lb_ratio","froude","resistance"],
                 index_col=False)

display(df.head())

df["pris_coeff"][df.pris_coeff.isnull() == True].index

df1 = df.copy()

df1.pris_coeff.fillna(method="bfill", inplace=True)

plt.figure(figsize=(12,8))
sns.heatmap(df1.corr(), annot=True, cmap="coolwarm")
plt.draw()



# Preprocssing Data

# Splitting data

X = df1.drop("resistance", axis=1).values

y = df1.resistance.values

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)

# Feature Scaling

scaler = StandardScaler()

X_train = scaler.fit_transform(X_train)

X_test = scaler.transform(X_test)

X_train.shape, X_test.shape, y_train.shape, y_test.shape

# Experimenting with the data

sgd = SGDRegressor()

scaler = StandardScaler()

r = np.random.randint(0,100000)
sc_dict = {}
gen_dict = {}
r2_sc = {}
y_pred = None

learning_rate_alpha = np.arange(0.001, 0.05, 0.01)
maximum_iter = np.arange(5000,15000,1000)

for alpha in learning_rate_alpha:
  for max_iterations in maximum_iter:

    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=r)
  
    X_train = scaler.fit_transform(X_train)
    X_test = scaler.transform(X_test)

    sc_dict[(np.round(alpha,3),max_iterations)] = SGDRegressor(alpha=alpha, max_iter=max_iterations).fit(X_train, y_train).score(X_train, y_train)*100
    gen_dict[(np.round(alpha,3),max_iterations)] = SGDRegressor(alpha=alpha, max_iter=max_iterations).fit(X_train, y_train).score(X_test, y_test)*100

# plotting the data

ll_tot = len(learning_rate_alpha) * len(maximum_iter)

plt.figure(figsize=(12,8))

plt.plot(np.arange(0,ll_tot), list(sc_dict.values()), color="blue", label="Model Score")
plt.plot(np.arange(0,ll_tot), list(gen_dict.values()), color="red", label="Generalization Score")

plt.title("SGDRegressor() function")
plt.xlabel("Learning Rate / Maximum Iterations")
plt.ylabel("Score")
plt.xticks(np.arange(ll_tot),list(sc_dict.keys()), rotation=90)

plt.legend(loc="center right")
plt.tight_layout()

plt.draw()

